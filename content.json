[{"title":"CSS","date":"2019-12-05T13:39:07.000Z","path":"2019/12/05/CSS/","text":"cssfont-variant属性：normal（默认） 转换大小写text-transform属性： none capitalize lowercase uppercase 水平的 horizontal 垂直的 Vertical","raw":"title: CSS\nauthor: Tzerocode\ndate: 2019-12-05 21:39:07\ntags:\n---\n# css\n\n## font-variant\n\n属性：normal（默认）\n\n\n## 转换大小写\n\ntext-transform属性：\n\nnone  capitalize  lowercase  uppercase\n\n水平的 horizontal\n\n垂直的 Vertical","content":"<h1 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h1><h2 id=\"font-variant\"><a href=\"#font-variant\" class=\"headerlink\" title=\"font-variant\"></a>font-variant</h2><p>属性：normal（默认）</p>\n<h2 id=\"转换大小写\"><a href=\"#转换大小写\" class=\"headerlink\" title=\"转换大小写\"></a>转换大小写</h2><p>text-transform属性：</p>\n<p>none  capitalize  lowercase  uppercase</p>\n<p>水平的 horizontal</p>\n<p>垂直的 Vertical</p>\n","slug":"CSS","updated":"2019-12-05T13:39:22.594Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/CSS/","excerpt":"","categories":[],"tags":[]},{"title":"Android个人积累","date":"2019-12-05T13:38:24.000Z","path":"2019/12/05/Android/","text":"Android Life Circle onAttach onCreate onCreateView onActivity onStart onResume onStop onDestoryView onDetach 1模拟器出现&#x2F;dev&#x2F;kvm23 sudo chown thacker -R &#x2F;dev&#x2F;kvm final 最终类型；不可以被修改，也就是常量的意思；private 私有的；只有类 内部才可以访问；default 系统默认值；它的访问权限是只有在同包和类内部可以访问；protected 保护的 ；在子类，同包，类内部都可以访问；public 公共的；任意的都可以访问","raw":"title: Android个人积累\nauthor: Tzerocode\ndate: 2019-12-05 21:38:24\ntags:\n---\nAndroid Life Circle\n\nonAttach\n\nonCreate\n\nonCreateView\n\nonActivity\n\nonStart\n\nonResume\n\nonStop\n\nonDestoryView\n\nonDetach\n\n```\n模拟器出现/dev/kvm\n\n sudo chown thacker -R /dev/kvm  \n```\n\n### final 最终类型；不可以被修改，也就是常量的意思；\n\n#### private 私有的；只有类 内部才可以访问；\n\n#### default 系统默认值；它的访问权限是只有在同包和类内部可以访问；\n\n### protected 保护的 ；在子类，同包，类内部都可以访问； \n\n### public 公共的；任意的都可以访问","content":"<p>Android Life Circle</p>\n<p>onAttach</p>\n<p>onCreate</p>\n<p>onCreateView</p>\n<p>onActivity</p>\n<p>onStart</p>\n<p>onResume</p>\n<p>onStop</p>\n<p>onDestoryView</p>\n<p>onDetach</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">模拟器出现&#x2F;dev&#x2F;kvm</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"> sudo chown thacker -R &#x2F;dev&#x2F;kvm</span></pre></td></tr></table></figure>\n\n<h3 id=\"final-最终类型；不可以被修改，也就是常量的意思；\"><a href=\"#final-最终类型；不可以被修改，也就是常量的意思；\" class=\"headerlink\" title=\"final 最终类型；不可以被修改，也就是常量的意思；\"></a>final 最终类型；不可以被修改，也就是常量的意思；</h3><h4 id=\"private-私有的；只有类-内部才可以访问；\"><a href=\"#private-私有的；只有类-内部才可以访问；\" class=\"headerlink\" title=\"private 私有的；只有类 内部才可以访问；\"></a>private 私有的；只有类 内部才可以访问；</h4><h4 id=\"default-系统默认值；它的访问权限是只有在同包和类内部可以访问；\"><a href=\"#default-系统默认值；它的访问权限是只有在同包和类内部可以访问；\" class=\"headerlink\" title=\"default 系统默认值；它的访问权限是只有在同包和类内部可以访问；\"></a>default 系统默认值；它的访问权限是只有在同包和类内部可以访问；</h4><h3 id=\"protected-保护的-；在子类，同包，类内部都可以访问；\"><a href=\"#protected-保护的-；在子类，同包，类内部都可以访问；\" class=\"headerlink\" title=\"protected 保护的 ；在子类，同包，类内部都可以访问；\"></a>protected 保护的 ；在子类，同包，类内部都可以访问；</h3><h3 id=\"public-公共的；任意的都可以访问\"><a href=\"#public-公共的；任意的都可以访问\" class=\"headerlink\" title=\"public 公共的；任意的都可以访问\"></a>public 公共的；任意的都可以访问</h3>","slug":"Android","updated":"2019-12-05T13:38:39.391Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/Android/","excerpt":"","categories":[],"tags":[]},{"title":"Android快捷键","date":"2019-12-05T13:36:36.000Z","path":"2019/12/05/Android快捷键/","text":"Android Studio快捷键 提取局部变量：Ctrl+Alt+V 提取全局变量：Ctrl+Alt+F 提取方法：Shit+Alt+M 搜索类的快捷键是Ctrl+N 继承类 Ctrl + F12 快速查看 Ctrl + H AS还是挺强大的,虽然很多功能都是IDEA提供的~","raw":"title: Android快捷键\nauthor: Tzerocode\ndate: 2019-12-05 21:36:36\ntags:\n---\nAndroid Studio快捷键\n\n提取局部变量：Ctrl+Alt+V\n\n提取全局变量：Ctrl+Alt+F\n\n提取方法：Shit+Alt+M\n\n搜索类的快捷键是Ctrl+N\n\n继承类 Ctrl + F12\n\n快速查看 Ctrl + H\n\n\n##### AS还是挺强大的,虽然很多功能都是IDEA提供的~~~","content":"<p>Android Studio快捷键</p>\n<p>提取局部变量：Ctrl+Alt+V</p>\n<p>提取全局变量：Ctrl+Alt+F</p>\n<p>提取方法：Shit+Alt+M</p>\n<p>搜索类的快捷键是Ctrl+N</p>\n<p>继承类 Ctrl + F12</p>\n<p>快速查看 Ctrl + H</p>\n<h5 id=\"AS还是挺强大的-虽然很多功能都是IDEA提供的\"><a href=\"#AS还是挺强大的-虽然很多功能都是IDEA提供的\" class=\"headerlink\" title=\"AS还是挺强大的,虽然很多功能都是IDEA提供的~\"></a>AS还是挺强大的,虽然很多功能都是IDEA提供的<del>~</del></h5>","slug":"Android快捷键","updated":"2019-12-05T13:38:02.460Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/Android%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","categories":[],"tags":[]},{"title":"Docker命令","date":"2019-12-05T13:33:28.000Z","path":"2019/12/05/Docker命令/","text":"docker个人使用过的操作指令记得那时因为php没办法在ubuntu上运行,只好用docker安装了php在容器里运行,并把端口映射出来,所以也学了点docker的基本操作进入容器sudo docker run -dit centosdocker container lsdocker attach IDdocker ps -a 查看运行过的容器docker images查看容器的镜像docker rmi 镜像id 就是删除镜像docker rm 容器id 就是删除镜像下的容器docker start 容器id启动容器（可以通过docker ps -a查看容器id）docker stop 容器id关闭容器systemctl enable docker.service 开机启动dockerdocker update –restart=always 容器idmongodocker run –name 容器的名字 -v /home/mongo_db（想要存放的目录）/data/db -p 127.0.0.1:27017:27017（这个是映射到外部的ip和端口） -d mongo(镜像名称或镜像ID)","raw":"title: Docker命令\nauthor: Tzerocode\ndate: 2019-12-05 21:33:28\ntags:\n---\n#### docker个人使用过的操作指令\n\n##### 记得那时因为php没办法在ubuntu上运行,只好用docker安装了php在容器里运行,并把端口映射出来,所以也学了点docker的基本操作\n\n\n### 进入容器\n\n##### sudo docker run -dit centos\n\n##### docker container ls\n\n##### docker attach ID\n\n##### docker ps -a 查看运行过的容器\n\n##### docker images查看容器的镜像\n\n##### docker rmi 镜像id 就是删除镜像\n\n##### docker rm 容器id 就是删除镜像下的容器\n\n##### docker start 容器id启动容器（可以通过docker ps -a查看容器id）\n\n##### docker stop 容器id关闭容器\n\n##### systemctl enable docker.service 开机启动docker\n\n##### docker update --restart=always 容器id\n\n### mongo\n\n##### docker run --name 容器的名字  -v /home/mongo_db（想要存放的目录）/data/db -p 127.0.0.1:27017:27017（这个是映射到外部的ip和端口） -d mongo(镜像名称或镜像ID)\n\n\n\n\n","content":"<h4 id=\"docker个人使用过的操作指令\"><a href=\"#docker个人使用过的操作指令\" class=\"headerlink\" title=\"docker个人使用过的操作指令\"></a>docker个人使用过的操作指令</h4><h5 id=\"记得那时因为php没办法在ubuntu上运行-只好用docker安装了php在容器里运行-并把端口映射出来-所以也学了点docker的基本操作\"><a href=\"#记得那时因为php没办法在ubuntu上运行-只好用docker安装了php在容器里运行-并把端口映射出来-所以也学了点docker的基本操作\" class=\"headerlink\" title=\"记得那时因为php没办法在ubuntu上运行,只好用docker安装了php在容器里运行,并把端口映射出来,所以也学了点docker的基本操作\"></a>记得那时因为php没办法在ubuntu上运行,只好用docker安装了php在容器里运行,并把端口映射出来,所以也学了点docker的基本操作</h5><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><h5 id=\"sudo-docker-run-dit-centos\"><a href=\"#sudo-docker-run-dit-centos\" class=\"headerlink\" title=\"sudo docker run -dit centos\"></a>sudo docker run -dit centos</h5><h5 id=\"docker-container-ls\"><a href=\"#docker-container-ls\" class=\"headerlink\" title=\"docker container ls\"></a>docker container ls</h5><h5 id=\"docker-attach-ID\"><a href=\"#docker-attach-ID\" class=\"headerlink\" title=\"docker attach ID\"></a>docker attach ID</h5><h5 id=\"docker-ps-a-查看运行过的容器\"><a href=\"#docker-ps-a-查看运行过的容器\" class=\"headerlink\" title=\"docker ps -a 查看运行过的容器\"></a>docker ps -a 查看运行过的容器</h5><h5 id=\"docker-images查看容器的镜像\"><a href=\"#docker-images查看容器的镜像\" class=\"headerlink\" title=\"docker images查看容器的镜像\"></a>docker images查看容器的镜像</h5><h5 id=\"docker-rmi-镜像id-就是删除镜像\"><a href=\"#docker-rmi-镜像id-就是删除镜像\" class=\"headerlink\" title=\"docker rmi 镜像id 就是删除镜像\"></a>docker rmi 镜像id 就是删除镜像</h5><h5 id=\"docker-rm-容器id-就是删除镜像下的容器\"><a href=\"#docker-rm-容器id-就是删除镜像下的容器\" class=\"headerlink\" title=\"docker rm 容器id 就是删除镜像下的容器\"></a>docker rm 容器id 就是删除镜像下的容器</h5><h5 id=\"docker-start-容器id启动容器（可以通过docker-ps-a查看容器id）\"><a href=\"#docker-start-容器id启动容器（可以通过docker-ps-a查看容器id）\" class=\"headerlink\" title=\"docker start 容器id启动容器（可以通过docker ps -a查看容器id）\"></a>docker start 容器id启动容器（可以通过docker ps -a查看容器id）</h5><h5 id=\"docker-stop-容器id关闭容器\"><a href=\"#docker-stop-容器id关闭容器\" class=\"headerlink\" title=\"docker stop 容器id关闭容器\"></a>docker stop 容器id关闭容器</h5><h5 id=\"systemctl-enable-docker-service-开机启动docker\"><a href=\"#systemctl-enable-docker-service-开机启动docker\" class=\"headerlink\" title=\"systemctl enable docker.service 开机启动docker\"></a>systemctl enable docker.service 开机启动docker</h5><h5 id=\"docker-update-–restart-always-容器id\"><a href=\"#docker-update-–restart-always-容器id\" class=\"headerlink\" title=\"docker update –restart=always 容器id\"></a>docker update –restart=always 容器id</h5><h3 id=\"mongo\"><a href=\"#mongo\" class=\"headerlink\" title=\"mongo\"></a>mongo</h3><h5 id=\"docker-run-–name-容器的名字-v-home-mongo-db（想要存放的目录）-data-db-p-127-0-0-1-27017-27017（这个是映射到外部的ip和端口）-d-mongo-镜像名称或镜像ID\"><a href=\"#docker-run-–name-容器的名字-v-home-mongo-db（想要存放的目录）-data-db-p-127-0-0-1-27017-27017（这个是映射到外部的ip和端口）-d-mongo-镜像名称或镜像ID\" class=\"headerlink\" title=\"docker run –name 容器的名字  -v /home/mongo_db（想要存放的目录）/data/db -p 127.0.0.1:27017:27017（这个是映射到外部的ip和端口） -d mongo(镜像名称或镜像ID)\"></a>docker run –name 容器的名字  -v /home/mongo_db（想要存放的目录）/data/db -p 127.0.0.1:27017:27017（这个是映射到外部的ip和端口） -d mongo(镜像名称或镜像ID)</h5>","slug":"Docker命令","updated":"2019-12-05T13:36:17.747Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/Docker%E5%91%BD%E4%BB%A4/","excerpt":"","categories":[],"tags":[]},{"title":"JavaScript-Es6","date":"2019-12-05T13:30:35.000Z","path":"2019/12/05/JavaScript-Es6/","text":"个人的ES6笔记const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用letArray 类型push()、pop()和shift()：以上都为方法栈数据结构的访问规则是 LIFO (后进先出),而队列数据结构的访问规则是 FIFO (First-In-First-Out,先进先出)es6提供了一个unshift方法就是与shift用途想法的方法unshift就是区别于shift，他是从后面推出，而不是从前面计算后推出 重排序方法reverse()和sort() ：也同为方法，为反选数组项的顺序reverse方法由于使用不方便所以才衍生出sort方法，而sort方法则思通过toString()转型方法去将字符转为ascll码进行比较，把最大放最后面，最小的则放在最前面。 concat()方法concat() 方法可以基于当前数组中的所有项创建一个新数组,他会将非数组项添加到已创建好的项目后面，并按照顺序排列。 例子： 1var colors = [\"red\",\"green\",\"blue\"];23var colors=colors.concat(\"yellow\",[\"black\",\"brown\"],\"white\"); slice()方法slice() 方法可以接受一或两个参数,即要返回项的起始和结束位置。 splice()方法splice插入的第二个参数为０，替换的第二个参数为１ 删除。例子：splice(0,2),删除数组中的前两项。 插入。例子：splice(2,0,”red”,”green”)从当前数组的位置 2 开始插入字符串 “red” 和 “green”。前两个项为参数，后面的项为可插入多个项。 替换。例子：splice(2,1,”red”,”green”)除当前数组位置 2 的项,然后再从位置 2 开始插入字符串“red” 和 “green”。 总结：插入原理应该也是替换，他就是将空的值提取存入到这个定义中，再把空出来的空间替换成定义的量。 例子： 1var colors = [\"red\", \"green\", \"blue\"];2var removed = colors.splice(0,1);3// 删除第一项4alert(colors);5// green,blue6alert(removed);7// red,返回的数组中只包含一项89removed = colors.splice(1, 0, \"yellow\", \"orange\");10alert(colors);11// green,yellow,orange,blue12alert(removed);13// 返回的是一个空数组 // 从位置 1 开始插入两项14removed = colors.splice(1, 1, \"red\", \"purple\");15alert(colors);16// green,red,purple,orange,blue17alert(removed);18// yellow,返回的数组中只包含一项 // 插入两项,删除一项 5.2.7 位置方法 indexOf() lastIndexOf() 这两个方法都接受两个参数，indexOf() 方法从数组的开头(位置 0)开始向后查找, lastIndexOf() 方法则从数组的末尾开始向前查找 这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1。 5.2.8 迭代方法 every() :对数组中的每一项运行给定函数,如果该函数对每一项都返回 true ,则返回 true 。 filter() :对数组中的每一项运行给定函数,返回该函数会返回 true 的项组成的数组。 forEach() :对数组中的每一项运行给定函数。这个方法没有返回值。 map() :对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。 some() :对数组中的每一项运行给定函数,如果该函数对任一项返回 true ,则返回 true 。 every()和some()都是用于查询数组中的项是否满足某个条件。 对 every() 来说,传入的函数必须对每一项都返回 true ,这个方法才返回 true ;否则,它就返回false 。而 some() 方法则是只要传入的函数对数组中的某一项返回 true ,就会返回 true 。例子： 1var numbers = [1,2,3,4,5,4,3,2,1];2var everyResult = numbers.every(function(item, index, array)&#123;3return (item &gt; 2);4&#125;);5alert(everyResult);6//false7var someResult = numbers.some(function(item, index, array)&#123;8return (item &gt; 2);9&#125;);10alert(someResult);11//true every() 和 some() , 传入的函数只要给定项大于 2 就会返回 true 。对于 every() ,它返回的是 false ,因为只有部分数组项符合条件。对于 some() ,结果就是 true ,因为至少有一项是大于 2 的。5.29归并方法两个归并数组的方法: reduce() 和 reduceRight()reduce()方法是从左往右求和，而reduceRight()则是通过相反方向也就是从右往左求和。5.3 Date类型Date.parse() 方法接收一个表示日期的字符串参数,根据这个字符串返回相应日期的毫秒数 5.4 RegExp 类型&amp;&amp;属性RegExp 的每个实例都具有下列属性,通过这些属性可以取得有关模式的各种信息。 global :布尔值,表示是否设置了 g 标志。 ignoreCase :布尔值,表示是否设置了 i 标志。 lastIndex :整数,表示开始搜索下一个匹配项的字符位置,从 0 算起。 multiline :布尔值,表示是否设置了 m 标志。source :正则表达式的字符串表示,按照字面量形式而非传入构造函数中的字符串模式返回。 通过这些属性可以获知一个正则表达式的各方面信息,但却没有多大用处,因为这些信息全都包含在模式声明中 例子： 1var pattern1 = /\\[bc\\]at/i;2alert(pattern1.global);3alert(pattern1.ignoreCase);4alert(pattern1.multiline);5alert(pattern1.lastIndex);6alert(pattern1.source);78var pattern2 = new RegExp(\"\\\\[bc\\\\]at\", \"i\");9alert(pattern2.global);10alert(pattern2.ignoreCase);11alert(pattern2.multiline);12alert(pattern2.lastIndex);13alert(pattern2.source); 5.4.2 RegExp实例方法RegExp 对象的主要方法是 exec()5.5.5 函数属性和方法apply(),call(),取决于采用哪种传递参数。如果有arguments对象，或者包括一个数组，那么使用apply()会更方便,否则使用call()更方便。 5.6 基本包装类型1var s1 = new String(\"some text\");2var s2 = s1.subString(2);3s1 = null; 以上分别适用Boolean和Number对应的布尔值和数字值 5.7 单体内置对象5.7.1 Global对象2.evel()方法evel()方法就像是一个完整的 ECMAScript 解析器,它只接受一个参数,即要执行的 ECMAScript (或 JavaScript)字符串。 1evel(\"alert('hi')\"); === alert(\"hi\") 当解析器发现代码中调用 eval() 方法时,它会将传入的参数当作实际的 ECMAScript 语句来解析,然后把执行结果插入到原位置。通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分,因此被执行的代码具有与该执行环境相同的作用域链。 ３.Global对象的属性Global包含的属性：undefined、NaN、Infinity ES5禁止给undefined、NaN、Infinity赋值。 5.7.2 Math对象2.max()和min()的方法 要找到数组中的最大或最小值,可以像下面这样使用 apply() 方法 例子: 1var values = [1,2,3,4,5,6,7,8];2var max = Math.max.apply(Math,values) 3. 舍入方法Math.ceil() 执行向上舍入,即它总是将数值向上舍入为最接近的整数;(无论小数多小都进１) Math.floor() 执行向下舍入,即它总是将数值向下舍入为最接近的整数;(无论小数多大，都舍去) Math.round() 执行标准舍入,即它总是将数值四舍五入为最接近的整数(5&lt;=进１) 4. random() 方法Math.random() 方法返回大于等于 0 小于 1 的一个随机数。 1var num = Math.floor(Math.random() * 10 + 1); 假设random = 0.3，则： num = 0.3 * 10 + 1 = 4; Math.floor()不看小数，直接取整。 函数 selectFrom() 接受两个参数:应该返回的最小值和最大值。而用最大值减最小值再加 1 得到了可能值的总数,然后它又把这些数值套用到了前面的公式中。这样,通过调用 selectFrom(2,10)就可以得到一个介于 2 和 10 之间(包括 2 和 10)的数值了。利用这个函数,可以方便地从数组中随机取出一项 例如: 1function selectFrom(lowerValue, upperValue) &#123;2var choices = upperValue - lowerValue + 1;3return Math.floor(Math.random() * choices + lowerValue);4&#125;5var num = selectFrom(2, 10);6alert(num);7// 介于 2 和 10 之间(包括 2 和 10)的一个数值 把 configurable 设置为 false ,表示不能从对象中删除属性","raw":"title: JavaScript-Es6\nauthor: Tzerocode\ndate: 2019-12-05 21:30:35\ntags:\n---\n## 个人的ES6笔记\n\n###### const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let\n\n\n\n##### Array 类型\n\n###### push()、pop()和shift()：以上都为方法\n\n###### 栈数据结构的访问规则是 LIFO (后进先出),而队列数据结构的访问规则是 FIFO (First-In-First-Out,先进先出)\n\n\n\n###### es6提供了一个unshift方法就是与shift用途想法的方法\n\nunshift就是区别于shift，他是从后面推出，而不是从前面计算后推出\n\n#### 重排序方法\n\n##### reverse()和sort() ：也同为方法，为反选数组项的顺序\n\nreverse方法由于使用不方便所以才衍生出sort方法，而sort方法则思通过toString()转型方法去将字符转为ascll码进行比较，把最大放最后面，最小的则放在最前面。\n\n####  concat()方法\n\nconcat() 方法可以基于当前数组中的所有项创建一个新数组,他会将非数组项添加到已创建好的项目后面，并按照顺序排列。\n\n例子：\n\n```js\nvar colors = [\"red\",\"green\",\"blue\"];\n\nvar colors=colors.concat(\"yellow\",[\"black\",\"brown\"],\"white\");\n```\n\n\n\n#### slice()方法\n\nslice() 方法可以接受一或两个参数,即要返回项的起始和结束位置。\n\n\n\n#### splice()方法\n\nsplice插入的第二个参数为０，替换的第二个参数为１\n\n- 删除。例子：splice(0,2),删除数组中的前两项。\n- 插入。例子：splice(2,0,\"red\",\"green\")从当前数组的位置 2 开始插入字符串 \"red\" 和 \"green\"。前两个项为参数，后面的项为可插入多个项。\n- 替换。例子：splice(2,1,\"red\",\"green\")除当前数组位置 2 的项,然后再从位置 2 开始插入字符串\n  \"red\" 和 \"green\"。\n\n总结：插入原理应该也是替换，他就是将空的值提取存入到这个定义中，再把空出来的空间替换成定义的量。\n\n例子：\n\n```js\nvar colors = [\"red\", \"green\", \"blue\"];\nvar removed = colors.splice(0,1);\n// 删除第一项\nalert(colors);\n// green,blue\nalert(removed);\n// red,返回的数组中只包含一项\n\nremoved = colors.splice(1, 0, \"yellow\", \"orange\");\nalert(colors);\n// green,yellow,orange,blue\nalert(removed);\n// 返回的是一个空数组 // 从位置 1 开始插入两项\nremoved = colors.splice(1, 1, \"red\", \"purple\");\nalert(colors);\n// green,red,purple,orange,blue\nalert(removed);\n// yellow,返回的数组中只包含一项 // 插入两项,删除一项\n```\n\n#### 5.2.7 位置方法\n\n- indexOf()\n- lastIndexOf()\n\n这两个方法都接受两个参数，indexOf() 方法从数组的开头(位置 0)开始向后查找, lastIndexOf() 方法则从数组的末尾开始向前查找\n\n这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1。\n\n\n\n#### 5.2.8 迭代方法\n\n1. every() :对数组中的每一项运行给定函数,如果该函数对每一项都返回 true ,则返回 true 。\n2. filter() :对数组中的每一项运行给定函数,返回该函数会返回 true 的项组成的数组。\n3. forEach() :对数组中的每一项运行给定函数。这个方法没有返回值。\n4. map() :对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。\n5. some() :对数组中的每一项运行给定函数,如果该函数对任一项返回 true ,则返回 true 。\n\nevery()和some()都是用于查询数组中的项是否满足某个条件。\n\n###### 对 every() 来说,传入的函数必须对每一项都返回 true ,这个方法才返回 true ;否则,它就返回false 。而 some() 方法则是只要传入的函数对数组中的某一项返回 true ,就会返回 true 。\n\n例子：\n\n```js\nvar numbers = [1,2,3,4,5,4,3,2,1];\nvar everyResult = numbers.every(function(item, index, array){\nreturn (item > 2);\n});\nalert(everyResult);\n//false\nvar someResult = numbers.some(function(item, index, array){\nreturn (item > 2);\n});\nalert(someResult);\n//true\n```\n\n\n\n###### every() 和 some() , 传入的函数只要给定项大于 2 就会返回 true 。对于 every() ,它返回的是 false ,因为只有部分数组项符合条件。对于 some() ,结果就是 true ,因为至少有一项是大于 2 的。\n\n\n\n#### 5.29归并方法\n\n###### 两个归并数组的方法: reduce() 和 reduceRight()\n\n###### reduce()方法是从左往右求和，而reduceRight()则是通过相反方向也就是从右往左求和。\n\n\n\n####  5.3 Date类型\n\n###### Date.parse() 方法接收一个表示日期的字符串参数,根据这个字符串返回相应日\n期的毫秒数\n \n\n#### 5.4 RegExp 类型&&属性\n\n\n\nRegExp 的每个实例都具有下列属性,通过这些属性可以取得有关模式的各种信息。\n\n- global :布尔值,表示是否设置了 g 标志。\n\n-  ignoreCase :布尔值,表示是否设置了 i 标志。\n\n-  lastIndex :整数,表示开始搜索下一个匹配项的字符位置,从 0 算起。\n\n-  multiline :布尔值,表示是否设置了 m 标志。\n   source :正则表达式的字符串表示,按照字面量形式而非传入构造函数中的字符串模式返回。\n\n  \n\n  ###### 通过这些属性可以获知一个正则表达式的各方面信息,但却没有多大用处,因为这些信息全都包含在模式声明中\n\n  例子：\n\n  ```js\n  var pattern1 = /\\[bc\\]at/i;\n  alert(pattern1.global);\n  alert(pattern1.ignoreCase);\n  alert(pattern1.multiline);\n  alert(pattern1.lastIndex);\n  alert(pattern1.source);\n  \n  var pattern2 = new RegExp(\"\\\\[bc\\\\]at\", \"i\");\n  alert(pattern2.global);\n  alert(pattern2.ignoreCase);\n  alert(pattern2.multiline);\n  alert(pattern2.lastIndex);\n  alert(pattern2.source);\n  ```\n\n  \n\n  #### 5.4.2　RegExp实例方法\n\n  ###### RegExp 对象的主要方法是 exec()\n\n  \n\n#### 5.5.5 函数属性和方法\n\napply(),call(),取决于采用哪种传递参数。如果有arguments对象，或者包括一个数组，那么使用apply()会更方便,否则使用call()更方便。\n\n\n\n#### 5.6　基本包装类型\n\n```js\nvar s1 = new String(\"some text\");\nvar s2 = s1.subString(2);\ns1 = null;\n```\n\n以上分别适用Boolean和Number对应的布尔值和数字值\n\n\n\n#### 5.7 单体内置对象\n\n#### 5.7.1 Global对象\n\n##### 2.evel()方法\n\nevel()方法就像是一个完整的 ECMAScript 解析器,它只接受一个参数,即要执行的 ECMAScript (或 JavaScript)字符串。\n\n```js\nevel(\"alert('hi')\"); === alert(\"hi\")\n```\n\n当解析器发现代码中调用 eval() 方法时,它会将传入的参数当作实际的 ECMAScript 语句来解析,然后把执行结果插入到原位置。通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分,因此被执行的代码具有与该执行环境相同的作用域链。\n\n\n\n#### ３.Global对象的属性\n\nGlobal包含的属性：undefined、NaN、Infinity\n\n![深度截图_选择区域_20190919084830](/home/thacker/图片/DOM/深度截图_选择区域_20190919084830.png)\n\nES5禁止给undefined、NaN、Infinity赋值。\n\n\n\n#### 5.7.2 Math对象\n\n2.max()和min()的方法\n\n要找到数组中的最大或最小值,可以像下面这样使用 apply() 方法\n\n例子:\n\n```js\nvar values = [1,2,3,4,5,6,7,8];\nvar max = Math.max.apply(Math,values)\n```\n\n#### 3. 舍入方法\n\nMath.ceil() 执行向上舍入,即它总是将数值向上舍入为最接近的整数;(无论小数多小都进１)\n\nMath.floor() 执行向下舍入,即它总是将数值向下舍入为最接近的整数;(无论小数多大，都舍去)\n\nMath.round() 执行标准舍入,即它总是将数值四舍五入为最接近的整数(5<=进１)\n\n#### 4. random() 方法\n\nMath.random() 方法返回大于等于 0 小于 1 的一个随机数。\n\n```js\nvar num = Math.floor(Math.random() * 10 + 1);\n```\n\n假设random = 0.3，则：\n\nnum = 0.3 * 10 + 1 = 4;\n\nMath.floor()不看小数，直接取整。\n\n函数 selectFrom() 接受两个参数:应该返回的最小值和最大值。而用最大值减最小值再加 1 得到\n了可能值的总数,然后它又把这些数值套用到了前面的公式中。这样,通过调用 selectFrom(2,10)\n就可以得到一个介于 2 和 10 之间(包括 2 和 10)的数值了。利用这个函数,可以方便地从数组中随机\n取出一项\n\n例如:\n\n```js\nfunction selectFrom(lowerValue, upperValue) {\nvar choices = upperValue - lowerValue + 1;\nreturn Math.floor(Math.random() * choices + lowerValue);\n}\nvar num = selectFrom(2, 10);\nalert(num);\n// 介于 2 和 10 之间(包括 2 和 10)的一个数值\n```\n\n把 configurable 设置为 false ,表示不能从对象中删除属性","content":"<h2 id=\"个人的ES6笔记\"><a href=\"#个人的ES6笔记\" class=\"headerlink\" title=\"个人的ES6笔记\"></a>个人的ES6笔记</h2><h6 id=\"const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let\"><a href=\"#const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let\" class=\"headerlink\" title=\"const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let\"></a>const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let</h6><h5 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h5><h6 id=\"push-、pop-和shift-：以上都为方法\"><a href=\"#push-、pop-和shift-：以上都为方法\" class=\"headerlink\" title=\"push()、pop()和shift()：以上都为方法\"></a>push()、pop()和shift()：以上都为方法</h6><h6 id=\"栈数据结构的访问规则是-LIFO-后进先出-而队列数据结构的访问规则是-FIFO-First-In-First-Out-先进先出\"><a href=\"#栈数据结构的访问规则是-LIFO-后进先出-而队列数据结构的访问规则是-FIFO-First-In-First-Out-先进先出\" class=\"headerlink\" title=\"栈数据结构的访问规则是 LIFO (后进先出),而队列数据结构的访问规则是 FIFO (First-In-First-Out,先进先出)\"></a>栈数据结构的访问规则是 LIFO (后进先出),而队列数据结构的访问规则是 FIFO (First-In-First-Out,先进先出)</h6><h6 id=\"es6提供了一个unshift方法就是与shift用途想法的方法\"><a href=\"#es6提供了一个unshift方法就是与shift用途想法的方法\" class=\"headerlink\" title=\"es6提供了一个unshift方法就是与shift用途想法的方法\"></a>es6提供了一个unshift方法就是与shift用途想法的方法</h6><p>unshift就是区别于shift，他是从后面推出，而不是从前面计算后推出</p>\n<h4 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h4><h5 id=\"reverse-和sort-：也同为方法，为反选数组项的顺序\"><a href=\"#reverse-和sort-：也同为方法，为反选数组项的顺序\" class=\"headerlink\" title=\"reverse()和sort() ：也同为方法，为反选数组项的顺序\"></a>reverse()和sort() ：也同为方法，为反选数组项的顺序</h5><p>reverse方法由于使用不方便所以才衍生出sort方法，而sort方法则思通过toString()转型方法去将字符转为ascll码进行比较，把最大放最后面，最小的则放在最前面。</p>\n<h4 id=\"concat-方法\"><a href=\"#concat-方法\" class=\"headerlink\" title=\"concat()方法\"></a>concat()方法</h4><p>concat() 方法可以基于当前数组中的所有项创建一个新数组,他会将非数组项添加到已创建好的项目后面，并按照顺序排列。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"blue\"</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=colors.concat(<span class=\"string\">\"yellow\"</span>,[<span class=\"string\">\"black\"</span>,<span class=\"string\">\"brown\"</span>],<span class=\"string\">\"white\"</span>);</span></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"slice-方法\"><a href=\"#slice-方法\" class=\"headerlink\" title=\"slice()方法\"></a>slice()方法</h4><p>slice() 方法可以接受一或两个参数,即要返回项的起始和结束位置。</p>\n<h4 id=\"splice-方法\"><a href=\"#splice-方法\" class=\"headerlink\" title=\"splice()方法\"></a>splice()方法</h4><p>splice插入的第二个参数为０，替换的第二个参数为１</p>\n<ul>\n<li>删除。例子：splice(0,2),删除数组中的前两项。</li>\n<li>插入。例子：splice(2,0,”red”,”green”)从当前数组的位置 2 开始插入字符串 “red” 和 “green”。前两个项为参数，后面的项为可插入多个项。</li>\n<li>替换。例子：splice(2,1,”red”,”green”)除当前数组位置 2 的项,然后再从位置 2 开始插入字符串<br>“red” 和 “green”。</li>\n</ul>\n<p>总结：插入原理应该也是替换，他就是将空的值提取存入到这个定义中，再把空出来的空间替换成定义的量。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removed = colors.splice(<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除第一项</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(colors);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// green,blue</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(removed);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// red,返回的数组中只包含一项</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">removed = colors.splice(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"string\">\"yellow\"</span>, <span class=\"string\">\"orange\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(colors);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// green,yellow,orange,blue</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(removed);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回的是一个空数组 // 从位置 1 开始插入两项</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">removed = colors.splice(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"string\">\"red\"</span>, <span class=\"string\">\"purple\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(colors);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// green,red,purple,orange,blue</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(removed);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// yellow,返回的数组中只包含一项 // 插入两项,删除一项</span></span></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-7-位置方法\"><a href=\"#5-2-7-位置方法\" class=\"headerlink\" title=\"5.2.7 位置方法\"></a>5.2.7 位置方法</h4><ul>\n<li>indexOf()</li>\n<li>lastIndexOf()</li>\n</ul>\n<p>这两个方法都接受两个参数，indexOf() 方法从数组的开头(位置 0)开始向后查找, lastIndexOf() 方法则从数组的末尾开始向前查找</p>\n<p>这两个方法都返回要查找的项在数组中的位置,或者在没找到的情况下返回-1。</p>\n<h4 id=\"5-2-8-迭代方法\"><a href=\"#5-2-8-迭代方法\" class=\"headerlink\" title=\"5.2.8 迭代方法\"></a>5.2.8 迭代方法</h4><ol>\n<li>every() :对数组中的每一项运行给定函数,如果该函数对每一项都返回 true ,则返回 true 。</li>\n<li>filter() :对数组中的每一项运行给定函数,返回该函数会返回 true 的项组成的数组。</li>\n<li>forEach() :对数组中的每一项运行给定函数。这个方法没有返回值。</li>\n<li>map() :对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。</li>\n<li>some() :对数组中的每一项运行给定函数,如果该函数对任一项返回 true ,则返回 true 。</li>\n</ol>\n<p>every()和some()都是用于查询数组中的项是否满足某个条件。</p>\n<h6 id=\"对-every-来说-传入的函数必须对每一项都返回-true-这个方法才返回-true-否则-它就返回false-。而-some-方法则是只要传入的函数对数组中的某一项返回-true-就会返回-true-。\"><a href=\"#对-every-来说-传入的函数必须对每一项都返回-true-这个方法才返回-true-否则-它就返回false-。而-some-方法则是只要传入的函数对数组中的某一项返回-true-就会返回-true-。\" class=\"headerlink\" title=\"对 every() 来说,传入的函数必须对每一项都返回 true ,这个方法才返回 true ;否则,它就返回false 。而 some() 方法则是只要传入的函数对数组中的某一项返回 true ,就会返回 true 。\"></a>对 every() 来说,传入的函数必须对每一项都返回 true ,这个方法才返回 true ;否则,它就返回false 。而 some() 方法则是只要传入的函数对数组中的某一项返回 true ,就会返回 true 。</h6><p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> everyResult = numbers.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, array</span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> (item &gt; <span class=\"number\">2</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(everyResult);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//false</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someResult = numbers.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, array</span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> (item &gt; <span class=\"number\">2</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(someResult);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//true</span></span></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"every-和-some-传入的函数只要给定项大于-2-就会返回-true-。对于-every-它返回的是-false-因为只有部分数组项符合条件。对于-some-结果就是-true-因为至少有一项是大于-2-的。\"><a href=\"#every-和-some-传入的函数只要给定项大于-2-就会返回-true-。对于-every-它返回的是-false-因为只有部分数组项符合条件。对于-some-结果就是-true-因为至少有一项是大于-2-的。\" class=\"headerlink\" title=\"every() 和 some() , 传入的函数只要给定项大于 2 就会返回 true 。对于 every() ,它返回的是 false ,因为只有部分数组项符合条件。对于 some() ,结果就是 true ,因为至少有一项是大于 2 的。\"></a>every() 和 some() , 传入的函数只要给定项大于 2 就会返回 true 。对于 every() ,它返回的是 false ,因为只有部分数组项符合条件。对于 some() ,结果就是 true ,因为至少有一项是大于 2 的。</h6><h4 id=\"5-29归并方法\"><a href=\"#5-29归并方法\" class=\"headerlink\" title=\"5.29归并方法\"></a>5.29归并方法</h4><h6 id=\"两个归并数组的方法-reduce-和-reduceRight\"><a href=\"#两个归并数组的方法-reduce-和-reduceRight\" class=\"headerlink\" title=\"两个归并数组的方法: reduce() 和 reduceRight()\"></a>两个归并数组的方法: reduce() 和 reduceRight()</h6><h6 id=\"reduce-方法是从左往右求和，而reduceRight-则是通过相反方向也就是从右往左求和。\"><a href=\"#reduce-方法是从左往右求和，而reduceRight-则是通过相反方向也就是从右往左求和。\" class=\"headerlink\" title=\"reduce()方法是从左往右求和，而reduceRight()则是通过相反方向也就是从右往左求和。\"></a>reduce()方法是从左往右求和，而reduceRight()则是通过相反方向也就是从右往左求和。</h6><h4 id=\"5-3-Date类型\"><a href=\"#5-3-Date类型\" class=\"headerlink\" title=\"5.3 Date类型\"></a>5.3 Date类型</h4><h6 id=\"Date-parse-方法接收一个表示日期的字符串参数-根据这个字符串返回相应日\"><a href=\"#Date-parse-方法接收一个表示日期的字符串参数-根据这个字符串返回相应日\" class=\"headerlink\" title=\"Date.parse() 方法接收一个表示日期的字符串参数,根据这个字符串返回相应日\"></a>Date.parse() 方法接收一个表示日期的字符串参数,根据这个字符串返回相应日</h6><p>期的毫秒数</p>\n<h4 id=\"5-4-RegExp-类型-amp-amp-属性\"><a href=\"#5-4-RegExp-类型-amp-amp-属性\" class=\"headerlink\" title=\"5.4 RegExp 类型&amp;&amp;属性\"></a>5.4 RegExp 类型&amp;&amp;属性</h4><p>RegExp 的每个实例都具有下列属性,通过这些属性可以取得有关模式的各种信息。</p>\n<ul>\n<li><p>global :布尔值,表示是否设置了 g 标志。</p>\n</li>\n<li><p>ignoreCase :布尔值,表示是否设置了 i 标志。</p>\n</li>\n<li><p>lastIndex :整数,表示开始搜索下一个匹配项的字符位置,从 0 算起。</p>\n</li>\n<li><p>multiline :布尔值,表示是否设置了 m 标志。<br>source :正则表达式的字符串表示,按照字面量形式而非传入构造函数中的字符串模式返回。</p>\n</li>\n</ul>\n<h6 id=\"通过这些属性可以获知一个正则表达式的各方面信息-但却没有多大用处-因为这些信息全都包含在模式声明中\"><a href=\"#通过这些属性可以获知一个正则表达式的各方面信息-但却没有多大用处-因为这些信息全都包含在模式声明中\" class=\"headerlink\" title=\"通过这些属性可以获知一个正则表达式的各方面信息,但却没有多大用处,因为这些信息全都包含在模式声明中\"></a>通过这些属性可以获知一个正则表达式的各方面信息,但却没有多大用处,因为这些信息全都包含在模式声明中</h6><p>  例子：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern1 = <span class=\"regexp\">/\\[bc\\]at/i</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern1.global);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern1.ignoreCase);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern1.multiline);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern1.lastIndex);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern1.source);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern2 = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"\\\\[bc\\\\]at\"</span>, <span class=\"string\">\"i\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern2.global);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern2.ignoreCase);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern2.multiline);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern2.lastIndex);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(pattern2.source);</span></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-4-2-RegExp实例方法\"><a href=\"#5-4-2-RegExp实例方法\" class=\"headerlink\" title=\"5.4.2　RegExp实例方法\"></a>5.4.2　RegExp实例方法</h4><h6 id=\"RegExp-对象的主要方法是-exec\"><a href=\"#RegExp-对象的主要方法是-exec\" class=\"headerlink\" title=\"RegExp 对象的主要方法是 exec()\"></a>RegExp 对象的主要方法是 exec()</h6><h4 id=\"5-5-5-函数属性和方法\"><a href=\"#5-5-5-函数属性和方法\" class=\"headerlink\" title=\"5.5.5 函数属性和方法\"></a>5.5.5 函数属性和方法</h4><p>apply(),call(),取决于采用哪种传递参数。如果有arguments对象，或者包括一个数组，那么使用apply()会更方便,否则使用call()更方便。</p>\n<h4 id=\"5-6-基本包装类型\"><a href=\"#5-6-基本包装类型\" class=\"headerlink\" title=\"5.6　基本包装类型\"></a>5.6　基本包装类型</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"some text\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.subString(<span class=\"number\">2</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = <span class=\"literal\">null</span>;</span></pre></td></tr></table></figure>\n\n<p>以上分别适用Boolean和Number对应的布尔值和数字值</p>\n<h4 id=\"5-7-单体内置对象\"><a href=\"#5-7-单体内置对象\" class=\"headerlink\" title=\"5.7 单体内置对象\"></a>5.7 单体内置对象</h4><h4 id=\"5-7-1-Global对象\"><a href=\"#5-7-1-Global对象\" class=\"headerlink\" title=\"5.7.1 Global对象\"></a>5.7.1 Global对象</h4><h5 id=\"2-evel-方法\"><a href=\"#2-evel-方法\" class=\"headerlink\" title=\"2.evel()方法\"></a>2.evel()方法</h5><p>evel()方法就像是一个完整的 ECMAScript 解析器,它只接受一个参数,即要执行的 ECMAScript (或 JavaScript)字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">evel(<span class=\"string\">\"alert('hi')\"</span>); === alert(<span class=\"string\">\"hi\"</span>)</span></pre></td></tr></table></figure>\n\n<p>当解析器发现代码中调用 eval() 方法时,它会将传入的参数当作实际的 ECMAScript 语句来解析,然后把执行结果插入到原位置。通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分,因此被执行的代码具有与该执行环境相同的作用域链。</p>\n<h4 id=\"３-Global对象的属性\"><a href=\"#３-Global对象的属性\" class=\"headerlink\" title=\"３.Global对象的属性\"></a>３.Global对象的属性</h4><p>Global包含的属性：undefined、NaN、Infinity</p>\n<p><img src=\"/.io/2019/12//thacker/%E5%9B%BE%E7%89%87/DOM/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190919084830.png\" alt=\"深度截图_选择区域_20190919084830\"></p>\n<p>ES5禁止给undefined、NaN、Infinity赋值。</p>\n<h4 id=\"5-7-2-Math对象\"><a href=\"#5-7-2-Math对象\" class=\"headerlink\" title=\"5.7.2 Math对象\"></a>5.7.2 Math对象</h4><p>2.max()和min()的方法</p>\n<p>要找到数组中的最大或最小值,可以像下面这样使用 apply() 方法</p>\n<p>例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>];</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>,values)</span></pre></td></tr></table></figure>\n\n<h4 id=\"3-舍入方法\"><a href=\"#3-舍入方法\" class=\"headerlink\" title=\"3. 舍入方法\"></a>3. 舍入方法</h4><p>Math.ceil() 执行向上舍入,即它总是将数值向上舍入为最接近的整数;(无论小数多小都进１)</p>\n<p>Math.floor() 执行向下舍入,即它总是将数值向下舍入为最接近的整数;(无论小数多大，都舍去)</p>\n<p>Math.round() 执行标准舍入,即它总是将数值四舍五入为最接近的整数(5&lt;=进１)</p>\n<h4 id=\"4-random-方法\"><a href=\"#4-random-方法\" class=\"headerlink\" title=\"4. random() 方法\"></a>4. random() 方法</h4><p>Math.random() 方法返回大于等于 0 小于 1 的一个随机数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">1</span>);</span></pre></td></tr></table></figure>\n\n<p>假设random = 0.3，则：</p>\n<p>num = 0.3 * 10 + 1 = 4;</p>\n<p>Math.floor()不看小数，直接取整。</p>\n<p>函数 selectFrom() 接受两个参数:应该返回的最小值和最大值。而用最大值减最小值再加 1 得到<br>了可能值的总数,然后它又把这些数值套用到了前面的公式中。这样,通过调用 selectFrom(2,10)<br>就可以得到一个介于 2 和 10 之间(包括 2 和 10)的数值了。利用这个函数,可以方便地从数组中随机<br>取出一项</p>\n<p>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectFrom</span>(<span class=\"params\">lowerValue, upperValue</span>) </span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> choices = upperValue - lowerValue + <span class=\"number\">1</span>;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * choices + lowerValue);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = selectFrom(<span class=\"number\">2</span>, <span class=\"number\">10</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">alert(num);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 介于 2 和 10 之间(包括 2 和 10)的一个数值</span></span></pre></td></tr></table></figure>\n\n<p>把 configurable 设置为 false ,表示不能从对象中删除属性</p>\n","slug":"JavaScript-Es6","updated":"2019-12-05T13:33:06.270Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/JavaScript-Es6/","excerpt":"","categories":[],"tags":[]},{"title":"JavaScript篇","date":"2019-12-05T13:29:15.000Z","path":"2019/12/05/JavaScript篇/","text":"个人学习JavaScript时的笔记很多都忘了,通过博客记录,希望加深印象和个人见解参数：形参和实参 形参：函数定义的时候函数名字后面的小括号里的变量就是参数，是不需要写var 形参：函数调用的时候小括号里传入的变量或者是值 返回值：函数中如果有return,那么这个函数就有返回值 如果函数没有 函数作用：代码重复使用 函数的参数： １．形参：函数定义的时候，函数名字后面的小括号里面的变量 ２．实参：函数调用的时候，函数名字后面的小括号里的变量或者值 返回值： 函数中有return，函数有返回值 函数中没有return，函数没有返回值 没有明确返回值：函数中没有return或者return后面没有任何内容 如果一个函数没有明确的返回值，接收这个函数，结果是undefined 无参数 无返回值 的函数 无参数 有返回值 的函数 有参数 无返回值 的函数 有参数 有返回值 的函数 arguments ——-&gt; 可以获取函数调用的时候，传入的实参的个数 arguments是一个对象，是一个伪数组 arguments.length ——&gt; 是实参的个数 arguments[索引] ——-&gt; 实参的值 作用域：变量的使用范围 全局作用域：全局变量在任何位置都可以使用的范围 局部作用域：局部变量只能在某个笛梵使用－－－函数内 作用域链：在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续向外面找这个变量，找到则使用，一直找到全局作用域，找不到则是undefined 全局变量：只要是在函数外面声明的变量都可以看成或者是理解成是全局变量 局部变量：在函数定义的变量 预解析：在执行代码之前做的事情 变量的声明和函数的声明被提前了，变量和函数的声明会提升到当前所在的作用域做的最上面 函数中的变量声明，会提升到该函数的作用域链的最上面(里面) 如果有多对script标签都有相同名字的函数，预解析的时候是分段的，互不影响 面向对象特性：封装，继承，多态 (抽象性) js不是面向对象的语言，但可以模拟面向对象的思想 js是一门基于对象的语言 什么是对象？ 看得见，摸得到，具体特指的某个东西 找对象 描述找对象 对象：有属性和方法，具体特指的某个事物 特征———-属性 行为———-方法 创建对象三种方式 １.调用系统的构造函数创建对象 ２.自定义构造函数创建对象（结合第一种和需求通过工厂模式创建对象） ３．字面量的方式创建对象 实例化对象 1var obj = new Object() 对象有特征－－－属性和行为－－－方法 添加属性－－－－如何添加属性？ 对象.名字＝值 obj.xx 就是添加属性 obj.xx = function(){ //代码 };就是方法（也就是通过匿名函数将对象名赋值给他） 工厂模式创建对象例子: 1function test(name,age)&#123;2 var obj = new Object();3 obj.name = name;4 obj.age = age;5 obj.sayHi = function()&#123;6 console.log(\"hello,我叫:\"+this.name+\"我今年：\"+\"this.age\")7 &#125;8 return obj9&#125;10//通过参数使用函数11person1 = test('小明',28);12person2 = test('小刚',21); 自定义函数例子: 1function Dog()&#123;2 this.name = name;3 this.age = age;4 this.sex = sex;5 this.sayHi=function()&#123;6 console.log(\"小狗的名字:\"+this.name+\"，年龄是:\"+this.age+\" 性别:\"+this.sex);7 &#125;8 var dog = new Dog(\"小黄\",10,\"公\");9 console.log(dog instanceof Person);//false10 console.log(dog instanceof Dog);//true11&#125; １．在内存中开辟（申请一块空闲的空间）空间，存储创建的新的对象 ２．把ｔｈｉｓ设置为当前的对象 ３．设置对象的属性和方法的值 ４．把ｔｈｉｓ这个对象返回 ３．字面量的方式创建对象例子: 1var obj &#x3D; &#123;&#125;;2obj.name &#x3D; &quot;小白&quot;;3obj.age &#x3D; 10;45obj.sayHi&#x3D;function()&#123;6 console.log(&quot;我是:&quot;+this.name);7&#125;8obj.sayHi();910&#x2F;&#x2F;优化后1112var obj2 &#x3D; &#123;13 name:&quot;小明&quot;,14 age:20,15 sayHi:function()&#123;16 console.log(&quot;我是:&quot;+this.name);17 &#125;,18 eat:function()&#123;19 console.log(&quot;吃了&quot;);20 &#125;21&#125;22obj2.sayHi();23obj2.eat(); js是一门什么样的语言? 是一门解释性的语言 是一门脚本语言 是一门弱类型语言，声明变量都用var 是一门基于对象的语言 是一门动态类的语言 １、代码(变量)只有执行到这个位置的时候，才知道这个变量中到底存储的是什么，如果是对象，就有对象的属性和方法，如果是变量就是变量的作用 ２、对象没有什么，只要点了，通过语法，那么就可以为对象添加属性或者方法 原始数据类型: number,string,boolean,undefined,null,object 基本类型（简单类型），值类型: number,string,boolean 复杂类型(引用类型):ｏｂｊｅｃｔ 空类型:undefined,null 值类型的值在那一块空间中存储？栈中存储 引用类型的值在哪一块空间中存储？栈和堆中存储 //值类型，值在栈上 var num =10; //复杂类型，对象在堆，地址(引用)在栈 var obj = {} //值类型之间传递，传递的是值 //引用类型之间传递，传递的是地址(地址)","raw":"title: JavaScript篇\nauthor: Tzerocode\ndate: 2019-12-05 21:29:15\ntags:\n---\n### 个人学习JavaScript时的笔记\n##### 很多都忘了,通过博客记录,希望加深印象和个人见解\n参数：形参和实参\n\n形参：函数定义的时候函数名字后面的小括号里的变量就是参数，是不需要写var\n\n形参：函数调用的时候小括号里传入的变量或者是值\n\n返回值：函数中如果有return,那么这个函数就有返回值\n\n如果函数没有\n\n\n\n\n\n函数作用：代码重复使用\n\n函数的参数：\n\n１．形参：函数定义的时候，函数名字后面的小括号里面的变量\n\n２．实参：函数调用的时候，函数名字后面的小括号里的变量或者值\n\n\n\n返回值：\n\n函数中有return，函数有返回值\n\n函数中没有return，函数没有返回值\n\n没有明确返回值：函数中没有return或者return后面没有任何内容\n\n如果一个函数没有明确的返回值，接收这个函数，结果是undefined\n\n\n\n\n\n无参数　无返回值　的函数\n\n无参数　有返回值　的函数\n\n有参数　无返回值　的函数\n\n有参数　有返回值　的函数\n\n\n\narguments -------> 可以获取函数调用的时候，传入的实参的个数\n\narguments是一个对象，是一个伪数组\n\narguments.length ------> 是实参的个数\n\narguments[索引] -------> 实参的值\n\n\n\n作用域：变量的使用范围\n\n全局作用域：全局变量在任何位置都可以使用的范围\n\n局部作用域：局部变量只能在某个笛梵使用－－－函数内\n\n作用域链：在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续向外面找这个变量，找到则使用，一直找到全局作用域，找不到则是undefined\n\n全局变量：只要是在函数外面声明的变量都可以看成或者是理解成是全局变量\n\n局部变量：在函数定义的变量\n\n\n\n预解析：在执行代码之前做的事情\n\n变量的声明和函数的声明被提前了，变量和函数的声明会提升到当前所在的作用域做的最上面\n\n函数中的变量声明，会提升到该函数的作用域链的最上面(里面)\n\n如果有多对script标签都有相同名字的函数，预解析的时候是分段的，互不影响\n\n\n\n面向对象特性：封装，继承，多态　(抽象性)\n\njs不是面向对象的语言，但可以模拟面向对象的思想\n\njs是一门基于对象的语言\n\n\n\n什么是对象？\n\n看得见，摸得到，具体特指的某个东西\n\n找对象\n\n描述找对象\n\n\n\n对象：有属性和方法，具体特指的某个事物\n\n\n\n特征----------属性\n\n行为----------方法\n\n\n\n创建对象三种方式\n\n１.**调用系统**的构造函数创建对象\n\n２.**自定义构造函数**创建对象（结合第一种和需求通过工厂模式创建对象）\n\n３．**字面量**的方式创建对象\n\n\n\n实例化对象\n\n```js\nvar obj = new Object()\n```\n\n对象有特征－－－属性和行为－－－方法\n\n添加属性－－－－如何添加属性？　对象.名字＝值\n\nobj.xx 就是添加属性\n\nobj.xx = function(){\n\n//代码\n\n};就是方法（也就是通过匿名函数将对象名赋值给他）\n\n\n\n## 工厂模式创建对象\n\n例子:\n\n```js\nfunction test(name,age){\n\tvar obj = new Object();\n\tobj.name = name;\n\tobj.age = age;\n\tobj.sayHi = function(){\n\t\tconsole.log(\"hello,我叫:\"+this.name+\"我今年：\"+\"this.age\")\n\t}\n\treturn obj\n}\n//通过参数使用函数\nperson1 = test('小明',28);\nperson2 = test('小刚',21);\n```\n\n## 自定义函数\n\n例子:\n\n```js\nfunction Dog(){\n\tthis.name = name;\n\tthis.age = age;\n\tthis.sex = sex;\n\tthis.sayHi=function(){\n\t\tconsole.log(\"小狗的名字:\"+this.name+\"，年龄是:\"+this.age+\" 性别:\"+this.sex);\n\t}\n\tvar dog = new Dog(\"小黄\",10,\"公\");\n\tconsole.log(dog instanceof Person);//false\n\tconsole.log(dog instanceof Dog);//true\n}\n```\n\n１．在内存中开辟（申请一块空闲的空间）空间，存储创建的新的对象\n\n２．把ｔｈｉｓ设置为当前的对象\n\n３．设置对象的属性和方法的值\n\n４．把ｔｈｉｓ这个对象返回\n\n\n\n## ３．字面量的方式创建对象\n\n例子:\n\n```\nvar obj = {};\nobj.name = \"小白\";\nobj.age = 10;\n\nobj.sayHi=function(){\n\tconsole.log(\"我是:\"+this.name);\n}\nobj.sayHi();\n\n//优化后\n\nvar obj2 = {\n\tname:\"小明\",\n\tage:20,\n\tsayHi:function(){\n\t\tconsole.log(\"我是:\"+this.name);\n\t},\n\teat:function(){\n\t\tconsole.log(\"吃了\");\n\t}\n}\nobj2.sayHi();\nobj2.eat();\n\n```\n\n\n\njs是一门什么样的语言?\n\n是一门解释性的语言\n\n是一门脚本语言\n\n是一门弱类型语言，声明变量都用var\n\n是一门基于对象的语言\n\n是一门动态类的语言\n\n１、代码(变量)只有执行到这个位置的时候，才知道这个变量中到底存储的是什么，如果是对象，就有对象的属性和方法，如果是变量就是变量的作用\n\n２、对象没有什么，只要点了，通过语法，那么就可以为对象添加属性或者方法\n\n\n\n原始数据类型: number,string,boolean,undefined,null,object\n\n基本类型（简单类型），值类型: number,string,boolean\n\n复杂类型(引用类型):ｏｂｊｅｃｔ\n\n空类型:undefined,null\n\n\n\n值类型的值在那一块空间中存储？栈中存储\n\n引用类型的值在哪一块空间中存储？栈和堆中存储\n\n//值类型，值在栈上\n\nvar num =10;\n\n//复杂类型，对象在堆，地址(引用)在栈\n\nvar obj = {}\n\n//值类型之间传递，传递的是值\n\n//引用类型之间传递，传递的是地址(地址)","content":"<h3 id=\"个人学习JavaScript时的笔记\"><a href=\"#个人学习JavaScript时的笔记\" class=\"headerlink\" title=\"个人学习JavaScript时的笔记\"></a>个人学习JavaScript时的笔记</h3><h5 id=\"很多都忘了-通过博客记录-希望加深印象和个人见解\"><a href=\"#很多都忘了-通过博客记录-希望加深印象和个人见解\" class=\"headerlink\" title=\"很多都忘了,通过博客记录,希望加深印象和个人见解\"></a>很多都忘了,通过博客记录,希望加深印象和个人见解</h5><p>参数：形参和实参</p>\n<p>形参：函数定义的时候函数名字后面的小括号里的变量就是参数，是不需要写var</p>\n<p>形参：函数调用的时候小括号里传入的变量或者是值</p>\n<p>返回值：函数中如果有return,那么这个函数就有返回值</p>\n<p>如果函数没有</p>\n<p>函数作用：代码重复使用</p>\n<p>函数的参数：</p>\n<p>１．形参：函数定义的时候，函数名字后面的小括号里面的变量</p>\n<p>２．实参：函数调用的时候，函数名字后面的小括号里的变量或者值</p>\n<p>返回值：</p>\n<p>函数中有return，函数有返回值</p>\n<p>函数中没有return，函数没有返回值</p>\n<p>没有明确返回值：函数中没有return或者return后面没有任何内容</p>\n<p>如果一个函数没有明确的返回值，接收这个函数，结果是undefined</p>\n<p>无参数　无返回值　的函数</p>\n<p>无参数　有返回值　的函数</p>\n<p>有参数　无返回值　的函数</p>\n<p>有参数　有返回值　的函数</p>\n<p>arguments ——-&gt; 可以获取函数调用的时候，传入的实参的个数</p>\n<p>arguments是一个对象，是一个伪数组</p>\n<p>arguments.length ——&gt; 是实参的个数</p>\n<p>arguments[索引] ——-&gt; 实参的值</p>\n<p>作用域：变量的使用范围</p>\n<p>全局作用域：全局变量在任何位置都可以使用的范围</p>\n<p>局部作用域：局部变量只能在某个笛梵使用－－－函数内</p>\n<p>作用域链：在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续向外面找这个变量，找到则使用，一直找到全局作用域，找不到则是undefined</p>\n<p>全局变量：只要是在函数外面声明的变量都可以看成或者是理解成是全局变量</p>\n<p>局部变量：在函数定义的变量</p>\n<p>预解析：在执行代码之前做的事情</p>\n<p>变量的声明和函数的声明被提前了，变量和函数的声明会提升到当前所在的作用域做的最上面</p>\n<p>函数中的变量声明，会提升到该函数的作用域链的最上面(里面)</p>\n<p>如果有多对script标签都有相同名字的函数，预解析的时候是分段的，互不影响</p>\n<p>面向对象特性：封装，继承，多态　(抽象性)</p>\n<p>js不是面向对象的语言，但可以模拟面向对象的思想</p>\n<p>js是一门基于对象的语言</p>\n<p>什么是对象？</p>\n<p>看得见，摸得到，具体特指的某个东西</p>\n<p>找对象</p>\n<p>描述找对象</p>\n<p>对象：有属性和方法，具体特指的某个事物</p>\n<p>特征———-属性</p>\n<p>行为———-方法</p>\n<p>创建对象三种方式</p>\n<p>１.<strong>调用系统</strong>的构造函数创建对象</p>\n<p>２.<strong>自定义构造函数</strong>创建对象（结合第一种和需求通过工厂模式创建对象）</p>\n<p>３．<strong>字面量</strong>的方式创建对象</p>\n<p>实例化对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span></pre></td></tr></table></figure>\n\n<p>对象有特征－－－属性和行为－－－方法</p>\n<p>添加属性－－－－如何添加属性？　对象.名字＝值</p>\n<p>obj.xx 就是添加属性</p>\n<p>obj.xx = function(){</p>\n<p>//代码</p>\n<p>};就是方法（也就是通过匿名函数将对象名赋值给他）</p>\n<h2 id=\"工厂模式创建对象\"><a href=\"#工厂模式创建对象\" class=\"headerlink\" title=\"工厂模式创建对象\"></a>工厂模式创建对象</h2><p>例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">name,age</span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tobj.name = name;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tobj.age = age;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tobj.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello,我叫:\"</span>+<span class=\"keyword\">this</span>.name+<span class=\"string\">\"我今年：\"</span>+<span class=\"string\">\"this.age\"</span>)</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">return</span> obj</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过参数使用函数</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">person1 = test(<span class=\"string\">'小明'</span>,<span class=\"number\">28</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">person2 = test(<span class=\"string\">'小刚'</span>,<span class=\"number\">21</span>);</span></pre></td></tr></table></figure>\n\n<h2 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h2><p>例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\"></span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">this</span>.sex = sex;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">this</span>.sayHi=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"小狗的名字:\"</span>+<span class=\"keyword\">this</span>.name+<span class=\"string\">\"，年龄是:\"</span>+<span class=\"keyword\">this</span>.age+<span class=\"string\">\" 性别:\"</span>+<span class=\"keyword\">this</span>.sex);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"小黄\"</span>,<span class=\"number\">10</span>,<span class=\"string\">\"公\"</span>);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> Person);<span class=\"comment\">//false</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">console</span>.log(dog <span class=\"keyword\">instanceof</span> Dog);<span class=\"comment\">//true</span></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr></table></figure>\n\n<p>１．在内存中开辟（申请一块空闲的空间）空间，存储创建的新的对象</p>\n<p>２．把ｔｈｉｓ设置为当前的对象</p>\n<p>３．设置对象的属性和方法的值</p>\n<p>４．把ｔｈｉｓ这个对象返回</p>\n<h2 id=\"３．字面量的方式创建对象\"><a href=\"#３．字面量的方式创建对象\" class=\"headerlink\" title=\"３．字面量的方式创建对象\"></a>３．字面量的方式创建对象</h2><p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;&#125;;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj.name &#x3D; &quot;小白&quot;;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj.age &#x3D; 10;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj.sayHi&#x3D;function()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tconsole.log(&quot;我是:&quot;+this.name);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj.sayHi();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;优化后</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\">var obj2 &#x3D; &#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tname:&quot;小明&quot;,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tage:20,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\tsayHi:function()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tconsole.log(&quot;我是:&quot;+this.name);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;,</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\">\teat:function()&#123;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tconsole.log(&quot;吃了&quot;);</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj2.sayHi();</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">obj2.eat();</span></pre></td></tr></table></figure>\n\n\n\n<p>js是一门什么样的语言?</p>\n<p>是一门解释性的语言</p>\n<p>是一门脚本语言</p>\n<p>是一门弱类型语言，声明变量都用var</p>\n<p>是一门基于对象的语言</p>\n<p>是一门动态类的语言</p>\n<p>１、代码(变量)只有执行到这个位置的时候，才知道这个变量中到底存储的是什么，如果是对象，就有对象的属性和方法，如果是变量就是变量的作用</p>\n<p>２、对象没有什么，只要点了，通过语法，那么就可以为对象添加属性或者方法</p>\n<p>原始数据类型: number,string,boolean,undefined,null,object</p>\n<p>基本类型（简单类型），值类型: number,string,boolean</p>\n<p>复杂类型(引用类型):ｏｂｊｅｃｔ</p>\n<p>空类型:undefined,null</p>\n<p>值类型的值在那一块空间中存储？栈中存储</p>\n<p>引用类型的值在哪一块空间中存储？栈和堆中存储</p>\n<p>//值类型，值在栈上</p>\n<p>var num =10;</p>\n<p>//复杂类型，对象在堆，地址(引用)在栈</p>\n<p>var obj = {}</p>\n<p>//值类型之间传递，传递的是值</p>\n<p>//引用类型之间传递，传递的是地址(地址)</p>\n","slug":"JavaScript篇","updated":"2019-12-05T13:30:16.203Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/JavaScript%E7%AF%87/","excerpt":"","categories":[],"tags":[]},{"title":"Mongo篇","date":"2019-12-05T13:28:21.000Z","path":"2019/12/05/Mongo篇/","text":"Mongo本人的操作手册 ^_^进入mongo,直接命令行键入mongo 查看数据库:show dbs 查看某个库:use db_name 查看某个库下的表:show tables 查看某个表下面的数据:db.表名.find().pretty() pretty()让代码更容易阅读 1db.collection.find(query, projection) query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 插入数据: use db_name db.表名.insert({ “name”:”test” }) 1&gt; show dbs -- 查看数据库列表23\\&gt; use admin --创建admin数据库，如果存在admin数据库则使用admin数据库45\\&gt; db ---显示当前使用的数据库名称67\\&gt; db.getName() ---显示当前使用的数据库名称89\\&gt; db.dropDatabase() --删当前使用的数据库1011\\&gt; db.repairDatabase() --修复当前数据库1213\\&gt; db.version() --当前数据库版本1415\\&gt; db.getMongo() --查看当前数据库的链接机器地址 1617\\&gt; db.stats() 显示当前数据库状态，包含数据库名称，集合个数，当前数据库大小 ...1819\\&gt; db.getCollectionNames() --查看数据库中有那些个集合（表）2021\\&gt; show collections --查看数据库中有那些个集合（表）2223\\&gt; db.person.drop() --删除当前集合（表）person 权限管理 db.createUser({ user: ‘用户名’, pwd: ‘密码’, roles: [{ role: ‘权限’, db: ‘库’ }] }) 1Read：允许用户读取指定数据库2readWrite：允许用户读写指定数据库3dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile4userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户5clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。6readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限7readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限8userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限9dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。10root：只在admin数据库中可用。超级账号，超级权限 远程服务器端口访问不了 1firewall-cmd --zone=public --permanent --add-port=27017/tcp 1firewall-cmd --reload 2.创建普通用户 use fooshow roles #可以查看角色db.createUser( {user: “simpleUser”,pwd: “123456”,roles: [“readWrite”,”dbAdmin”,”userAdmin”] } )3.查看已存在的用户 db.system.users.find() 4.删除用户 db.system.users.remove({user:”simpleUser”})","raw":"title: Mongo篇\nauthor: Tzerocode\ndate: 2019-12-05 21:28:21\ntags:\n---\n## Mongo本人的操作手册 ^_^\n\n进入mongo,直接命令行键入mongo\n\n查看数据库:show dbs\n\n查看某个库:use db_name\n\n查看某个库下的表:show tables\n\n查看某个表下面的数据:db.表名.find().pretty()\n\n pretty()让代码更容易阅读\n\n```\ndb.collection.find(query, projection)\n```\n\n- **query** ：可选，使用查询操作符指定查询条件\n- **projection** ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n插入数据:\n\nuse db_name\n\ndb.表名.insert({ \"name\":\"test\" })\n\n```\n> show dbs    -- 查看数据库列表\n\n\\> use admin   --创建admin数据库，如果存在admin数据库则使用admin数据库\n\n\\> db   ---显示当前使用的数据库名称\n\n\\> db.getName()  ---显示当前使用的数据库名称\n\n\\> db.dropDatabase()  --删当前使用的数据库\n\n\\> db.repairDatabase()  --修复当前数据库\n\n\\> db.version()   --当前数据库版本\n\n\\> db.getMongo()  --查看当前数据库的链接机器地址 \n\n\\> db.stats() 显示当前数据库状态，包含数据库名称，集合个数，当前数据库大小 ...\n\n\\> db.getCollectionNames()   --查看数据库中有那些个集合（表）\n\n\\> show collections    --查看数据库中有那些个集合（表）\n\n\\> db.person.drop()  --删除当前集合（表）person\n```\n\n权限管理\n\ndb.createUser({ user: '用户名', pwd: '密码', roles: [{ role: '权限', db: '库' }] })\n\n```\nRead：允许用户读取指定数据库\nreadWrite：允许用户读写指定数据库\ndbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile\nuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户\nclusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。\nreadAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限\nreadWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限\nuserAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限\ndbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。\nroot：只在admin数据库中可用。超级账号，超级权限\n```\n\n远程服务器端口访问不了\n\n```cpp\nfirewall-cmd --zone=public --permanent --add-port=27017/tcp\n```\n\n \n\n```cpp\nfirewall-cmd --reload\n```\n\n2.创建普通用户\n\n  >use foo\n  >show roles #可以查看角色\n  >db.createUser(\n  >    {\n  >user: \"simpleUser\",\n  >pwd: “123456”,\n  >roles: [“readWrite”,”dbAdmin”,”userAdmin”]\n  >    }\n  >  )\n  >3.查看已存在的用户\n\n>db.system.users.find()\n\n\n4.删除用户\n\n>db.system.users.remove({user:”simpleUser”})","content":"<h2 id=\"Mongo本人的操作手册\"><a href=\"#Mongo本人的操作手册\" class=\"headerlink\" title=\"Mongo本人的操作手册 ^_^\"></a>Mongo本人的操作手册 ^_^</h2><p>进入mongo,直接命令行键入mongo</p>\n<p>查看数据库:show dbs</p>\n<p>查看某个库:use db_name</p>\n<p>查看某个库下的表:show tables</p>\n<p>查看某个表下面的数据:db.表名.find().pretty()</p>\n<p> pretty()让代码更容易阅读</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.find(query, projection)</span></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li>\n<li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li>\n</ul>\n<p>插入数据:</p>\n<p>use db_name</p>\n<p>db.表名.insert({ “name”:”test” })</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; show dbs    -- 查看数据库列表</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; use admin   --创建admin数据库，如果存在admin数据库则使用admin数据库</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db   ---显示当前使用的数据库名称</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.getName()  ---显示当前使用的数据库名称</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.dropDatabase()  --删当前使用的数据库</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">11</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.repairDatabase()  --修复当前数据库</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">12</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">13</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.version()   --当前数据库版本</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">14</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">15</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.getMongo()  --查看当前数据库的链接机器地址 </span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">16</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">17</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.stats() 显示当前数据库状态，包含数据库名称，集合个数，当前数据库大小 ...</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">18</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">19</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.getCollectionNames()   --查看数据库中有那些个集合（表）</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">20</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">21</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; show collections    --查看数据库中有那些个集合（表）</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">22</span></pre></td><td class=\"code\"><pre><span class=\"line\"></span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">23</span></pre></td><td class=\"code\"><pre><span class=\"line\">\\&gt; db.person.drop()  --删除当前集合（表）person</span></pre></td></tr></table></figure>\n\n<p>权限管理</p>\n<p>db.createUser({ user: ‘用户名’, pwd: ‘密码’, roles: [{ role: ‘权限’, db: ‘库’ }] })</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">Read：允许用户读取指定数据库</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">readWrite：允许用户读写指定数据库</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">3</span></pre></td><td class=\"code\"><pre><span class=\"line\">dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">4</span></pre></td><td class=\"code\"><pre><span class=\"line\">userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">5</span></pre></td><td class=\"code\"><pre><span class=\"line\">clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">6</span></pre></td><td class=\"code\"><pre><span class=\"line\">readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">7</span></pre></td><td class=\"code\"><pre><span class=\"line\">readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">8</span></pre></td><td class=\"code\"><pre><span class=\"line\">userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">9</span></pre></td><td class=\"code\"><pre><span class=\"line\">dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">10</span></pre></td><td class=\"code\"><pre><span class=\"line\">root：只在admin数据库中可用。超级账号，超级权限</span></pre></td></tr></table></figure>\n\n<p>远程服务器端口访问不了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=<span class=\"keyword\">public</span> --permanent --add-port=<span class=\"number\">27017</span>/tcp</span></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --reload</span></pre></td></tr></table></figure>\n\n<p>2.创建普通用户</p>\n<blockquote>\n<p>use foo<br>show roles #可以查看角色<br>db.createUser(<br>   {<br>user: “simpleUser”,<br>pwd: “123456”,<br>roles: [“readWrite”,”dbAdmin”,”userAdmin”]<br>   }<br> )<br>3.查看已存在的用户</p>\n</blockquote>\n<blockquote>\n<p>db.system.users.find()</p>\n</blockquote>\n<p>4.删除用户</p>\n<blockquote>\n<p>db.system.users.remove({user:”simpleUser”})</p>\n</blockquote>\n","slug":"Mongo篇","updated":"2019-12-05T13:28:51.918Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/Mongo%E7%AF%87/","excerpt":"","categories":[],"tags":[]},{"title":"MySql篇","date":"2019-12-05T05:11:00.000Z","path":"2019/12/05/第一篇博客/","text":"MySql的各种操作积累查询表的字段信息:desc table(表名); 查看数据库：show databases； 查看某个数据库：user database（数据库名）； 查看当前使用的表：show tables； 查询 表中的数据 select * from 表名; 插入数据 insert into 表名(字段1，字段2，…，字段n) values(值1，值2，…，值n); 例如： 1insert into dif(st_title,st_author,submission_data) values (&quot;学习&quot;,&quot;hello&quot;,&quot;2016-07-09&quot;); 查询语句 1SELECT field1, field2,...fieldN FROM table_name1, table_name2...2[WHERE condition1 [AND [OR]] condition2..... 例子： 1select * from where st_author &#x3D; &quot;怎么样&quot;; mysql复制表的两种方式。 第一、只复制表结构到新表 1create table 新表 select * from 旧表 where 1&#x3D;2 或者 1create table 新表 like 旧表 第二、复制表结构及数据到新表 1create table新表 select * from 旧表 数据库备份 mysqldump -hlocalhost -u boke -p hello &gt; /home/thacker/文档/mysql_backup/my_sql_dump.sql mysqldump -h数据库地址 -u 用户名 -p 回车后写密码 数据库名 &gt;(到的意思) 存放地址/备份数据名称.sql 恢复数据库 create database my_database;(为了直观看出恢复，创建了个表) mysql -u boke -p hello1(随意数据库名称) &lt; /home/thacker/文档/mysql_backup/my_sql_dump.sql mysql -u 用户名 -p 回车后写密码 数据库名 &lt;(到的意思) 存放地址/备份数据名称.sql 解决外健约束问题 alter table 表名 nocheck(不检查) constraint(约束) FK_约束的外键 INSERT JOIN（内连接） 检查两个表，连接两个表相同的字段信息 select 字段名*n from student s insert join class c on s.class_id = c.id 可选：加上WHERE子句、ORDER BY等子句。 outer join(外连接) select 字段名*n from student s outer join class c on s.class_id = c.id MySQL删除表操作（delete、truncate、drop的区别）区别1、表和索引所占空间： 当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小； DELETE操作不会减少表或索引所占用的空间； DROP语句将表所占用的空间全释放掉。 2、应用范围： TRUNCATE 只能对table； DELETE可以是table和view。 3、执行速度： drop &gt; truncate &gt; delete 4、delete from删空表后，会保留一个空的页，truncate在表中不会留有任何页。 5、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。 TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 6、当使用行锁执行 DELETE 语句时，将锁定表中各行以便删除。truncate始终锁定表和页，而不是锁定各行。 7、如果有identity产生的自增id列，delete from后仍然从上次的数开始增加，即种子不变； 使用truncate删除之后，种子会恢复到初始值。 总结1、delete 语句可以使用where子句实现部分删除，而truncate不可以，会将表中的整个数据全部删除，使用时，可以按需求选择；2、如果想从表中删除所有的数据，不要使用delete，可以使用truncate语句，因为这样执行速度更快。truncate语句实际是删除原来的表然后重新建立一个新表；3、在没有备份情况下，谨慎使用 drop 与 truncate。要删除表结构使用drop;4、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 通过个人的各方收集,以及各种瞎折腾,会不定期更新!!!","raw":"title: MySql篇\nauthor: Tzerocode\ntags:\n  - blog\ncategories:\n  - 博客\ndate: 2019-12-05 13:11:00\n---\n## MySql的各种操作积累\n\n查询表的字段信息:desc table(表名);\n\n查看数据库：show databases；\n\n查看某个数据库：user database（数据库名）；\n\n查看当前使用的表：show tables；\n\n查询 表中的数据 select * from 表名;\n\n插入数据 insert into 表名(字段1，字段2，...，字段n) values(值1，值2，...，值n);\n\n例如：\n\n```mysql\ninsert into dif(st_title,st_author,submission_data) values (\"学习\",\"hello\",\"2016-07-09\");\n```\n\n\n\n查询语句\n\n```mysql\nSELECT field1, field2,...fieldN FROM table_name1, table_name2...\n[WHERE condition1 [AND [OR]] condition2.....\n```\n\n例子：\n\n```\nselect * from  where st_author = \"怎么样\"; \n```\n\n\n\nmysql复制表的两种方式。\n\n第一、只复制表结构到新表\n\n```mysql\ncreate table 新表 select * from 旧表 where 1=2\n```\n\n或者\n\n```mysql\ncreate table 新表 like 旧表 \n```\n\n第二、复制表结构及数据到新表\n\n```mysql\ncreate table新表 select * from 旧表 \n```\n\n数据库备份\n\nmysqldump -hlocalhost -u boke -p hello > /home/thacker/文档/mysql_backup/my_sql_dump.sql\n\nmysqldump -h数据库地址 -u 用户名 -p 回车后写密码 数据库名 >(到的意思) 存放地址/备份数据名称.sql\n\n恢复数据库\n\ncreate database my_database;(为了直观看出恢复，创建了个表)\n\nmysql -u boke -p hello1(随意数据库名称) < /home/thacker/文档/mysql_backup/my_sql_dump.sql\n\nmysql  -u 用户名 -p 回车后写密码 数据库名 <(到的意思) 存放地址/备份数据名称.sql\n\n\n\n解决外健约束问题\n\nalter table 表名\n\nnocheck(不检查) constraint(约束) FK_约束的外键\n\n\n\nINSERT JOIN（内连接）\n\n检查两个表，连接两个表相同的字段信息\n\nselect 字段名*n\n\nfrom student s\n\ninsert join class c\n\non s.class_id = c.id\n\n可选：加上`WHERE`子句、`ORDER BY`等子句。\n\n\n\nouter join(外连接)\n\nselect 字段名*n\n\nfrom student s\n\nouter join class c\n\non s.class_id = c.id\n\n##### MySQL删除表操作（delete、truncate、drop的区别）\n\n\n\n区别\n1、表和索引所占空间：\n　　当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小；\n　　DELETE操作不会减少表或索引所占用的空间；\n　　DROP语句将表所占用的空间全释放掉。\n　　\n2、应用范围：\n　　TRUNCATE 只能对table；\n　　DELETE可以是table和view。\n\n3、执行速度：\n　　drop > truncate > delete\n\n4、delete from删空表后，会保留一个空的页，truncate在表中不会留有任何页。\n\n5、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。\n　　TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。\n\n6、当使用行锁执行 DELETE 语句时，将锁定表中各行以便删除。truncate始终锁定表和页，而不是锁定各行。\n\n7、如果有identity产生的自增id列，delete from后仍然从上次的数开始增加，即种子不变；\n　使用truncate删除之后，种子会恢复到初始值。\n\n\n\n总结\n1、delete 语句可以使用where子句实现部分删除，而truncate不可以，会将表中的整个数据全部删除，使用时，可以按需求选择；\n2、如果想从表中删除所有的数据，不要使用delete，可以使用truncate语句，因为这样执行速度更快。truncate语句实际是删除原来的表然后重新建立一个新表；\n3、在没有备份情况下，谨慎使用 drop 与 truncate。要删除表结构使用drop;\n4、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。\n\n#### 通过个人的各方收集,以及各种瞎折腾,会不定期更新!!!","content":"<h2 id=\"MySql的各种操作积累\"><a href=\"#MySql的各种操作积累\" class=\"headerlink\" title=\"MySql的各种操作积累\"></a>MySql的各种操作积累</h2><p>查询表的字段信息:desc table(表名);</p>\n<p>查看数据库：show databases；</p>\n<p>查看某个数据库：user database（数据库名）；</p>\n<p>查看当前使用的表：show tables；</p>\n<p>查询 表中的数据 select * from 表名;</p>\n<p>插入数据 insert into 表名(字段1，字段2，…，字段n) values(值1，值2，…，值n);</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">insert into dif(st_title,st_author,submission_data) values (&quot;学习&quot;,&quot;hello&quot;,&quot;2016-07-09&quot;);</span></pre></td></tr></table></figure>\n\n\n\n<p>查询语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span></pre></td></tr><tr><td class=\"gutter\"><pre><span class=\"line\">2</span></pre></td><td class=\"code\"><pre><span class=\"line\">[WHERE condition1 [AND [OR]] condition2.....</span></pre></td></tr></table></figure>\n\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">select * from  where st_author &#x3D; &quot;怎么样&quot;;</span></pre></td></tr></table></figure>\n\n\n\n<p>mysql复制表的两种方式。</p>\n<p>第一、只复制表结构到新表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">create table 新表 select * from 旧表 where 1&#x3D;2</span></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">create table 新表 like 旧表</span></pre></td></tr></table></figure>\n\n<p>第二、复制表结构及数据到新表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span></pre></td><td class=\"code\"><pre><span class=\"line\">create table新表 select * from 旧表</span></pre></td></tr></table></figure>\n\n<p>数据库备份</p>\n<p>mysqldump -hlocalhost -u boke -p hello &gt; /home/thacker/文档/mysql_backup/my_sql_dump.sql</p>\n<p>mysqldump -h数据库地址 -u 用户名 -p 回车后写密码 数据库名 &gt;(到的意思) 存放地址/备份数据名称.sql</p>\n<p>恢复数据库</p>\n<p>create database my_database;(为了直观看出恢复，创建了个表)</p>\n<p>mysql -u boke -p hello1(随意数据库名称) &lt; /home/thacker/文档/mysql_backup/my_sql_dump.sql</p>\n<p>mysql  -u 用户名 -p 回车后写密码 数据库名 &lt;(到的意思) 存放地址/备份数据名称.sql</p>\n<p>解决外健约束问题</p>\n<p>alter table 表名</p>\n<p>nocheck(不检查) constraint(约束) FK_约束的外键</p>\n<p>INSERT JOIN（内连接）</p>\n<p>检查两个表，连接两个表相同的字段信息</p>\n<p>select 字段名*n</p>\n<p>from student s</p>\n<p>insert join class c</p>\n<p>on s.class_id = c.id</p>\n<p>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</p>\n<p>outer join(外连接)</p>\n<p>select 字段名*n</p>\n<p>from student s</p>\n<p>outer join class c</p>\n<p>on s.class_id = c.id</p>\n<h5 id=\"MySQL删除表操作（delete、truncate、drop的区别）\"><a href=\"#MySQL删除表操作（delete、truncate、drop的区别）\" class=\"headerlink\" title=\"MySQL删除表操作（delete、truncate、drop的区别）\"></a>MySQL删除表操作（delete、truncate、drop的区别）</h5><p>区别<br>1、表和索引所占空间：<br>　　当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小；<br>　　DELETE操作不会减少表或索引所占用的空间；<br>　　DROP语句将表所占用的空间全释放掉。<br>　　<br>2、应用范围：<br>　　TRUNCATE 只能对table；<br>　　DELETE可以是table和view。</p>\n<p>3、执行速度：<br>　　drop &gt; truncate &gt; delete</p>\n<p>4、delete from删空表后，会保留一个空的页，truncate在表中不会留有任何页。</p>\n<p>5、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。<br>　　TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>\n<p>6、当使用行锁执行 DELETE 语句时，将锁定表中各行以便删除。truncate始终锁定表和页，而不是锁定各行。</p>\n<p>7、如果有identity产生的自增id列，delete from后仍然从上次的数开始增加，即种子不变；<br>　使用truncate删除之后，种子会恢复到初始值。</p>\n<p>总结<br>1、delete 语句可以使用where子句实现部分删除，而truncate不可以，会将表中的整个数据全部删除，使用时，可以按需求选择；<br>2、如果想从表中删除所有的数据，不要使用delete，可以使用truncate语句，因为这样执行速度更快。truncate语句实际是删除原来的表然后重新建立一个新表；<br>3、在没有备份情况下，谨慎使用 drop 与 truncate。要删除表结构使用drop;<br>4、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>\n<h4 id=\"通过个人的各方收集-以及各种瞎折腾-会不定期更新\"><a href=\"#通过个人的各方收集-以及各种瞎折腾-会不定期更新\" class=\"headerlink\" title=\"通过个人的各方收集,以及各种瞎折腾,会不定期更新!!!\"></a>通过个人的各方收集,以及各种瞎折腾,会不定期更新!!!</h4>","slug":"第一篇博客","updated":"2019-12-05T13:27:49.900Z","comments":true,"link":"","permalink":"tzerocode.github.io/2019/12/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","categories":[{"name":"博客","slug":"博客","permalink":"tzerocode.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"blog","slug":"blog","permalink":"tzerocode.github.io/tags/blog/"}]}]